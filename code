
clc
clear
%% 模型设置
% 变量个数、约束条件设置
nvars = 66; % 变量个数
% 约束条件形式1：下限与上限（若无取空数组[]）
% lb<= X <= ub
lb = zeros*ones(1,nvars);
ub = 407160*ones(1,nvars);
% 约束条件形式2：线性不等式约束（若无取空数组[]）
% A*X <= b 
A = [];
b = [];
% 约束条件形式3：线性等式约束（若无取空数组[]）
% Aeq*X == beq
Aeq = [];
beq = [];
% 约束条件形式4：非线性约束（若无取空数组[]）
% function [c,ceq] = Con_Fun(x)
% c = ... % Compute nonlinear inequalities at x; c <= 0;
% ceq = ... % Compute nonlinear equalities at x; ceq = 0;
% nonlcon = @Con_Fun;
nonlcon = @Con_Fun;
%% 求解器设置
options = gaoptimset();
options.ParetoFraction = 0.4; % 最优个体系数
options.PopulationSize = 500; % 种群大小
options.Generations = 300; % 最大进化代数
options.StallGenLimit = 100; % 停止代数
options.TolFun = 1e-6; % 适应度函数偏差
options.HybridFcn = @fgoalattain; % GA优化后获得初始值代入标准优化器
options.PlotFcns = @gaplotpareto; % 
%% 主求解
fitnessfcn = @Obj_Fun1; % 适应度函数的函数句柄
% 求解
tic
[x,fval] = gamultiobj(fitnessfcn,nvars,A,b,Aeq,beq,lb,ub,nonlcon,options);
toc
%%
function F = Obj_Fun1(x)
%UNTITLED2 此处显示有关此函数的摘要
% 此处显示详细说明
% 目标函数
X = reshape(x,6,11);
Y = zeros(6,11);
Y(X>0) = 1;
tij = [710,984,331,740,349,438,417,442,49.75,41,34.75;
504,1006,182,478,357,454,435,338,67.25,89.75,74.25;
543,1022,320,771,342,463,411,462,66.75,70.25,72.25;
504,1010,347,531,328,454,386,455,87.75,74,76.25;
512,831,306,687,346,414,400,427,42,70.25,64.25;
499,864,287,674,320,446,393,452,87,94.25,87];
F(1) = sum(sum(tij.*Y));
cij = [399,600,224,509,228,307,285,312,24.3,12.8,5.6;
377,618,279,707,259,330,306,470,46.5,87.65,78.4;
406,625,225,514,232,334,286,338,53.2,39.05,41.0;
377,618,241,796,228,330,269,332,90.6,44.4,33.7;
409,618,208,483,258,326,301,327,8.0,44.05,32.7;
393,646,199,483,233,349,286,356,90.6,81.6,82.8];
% 定义受灾点到应急点的距离矩阵
dij = [810,1350,485,1120,510,710,675,680,51,22,12;
830,1400,420,1050,550,765,720,740,65,87,76;
805,1390,480,1120,515,750,680,725,6,60,50;
780,1380,520,1150,470, 724,640,710,55,54,56;
830,1370,450,1090, 540,720,700,705,37,55,45;
790,1420,440,1075,520,790,690,760,30,95,85];
% 目标函数2
F(2) = sum(sum(X.*Y.*cij));
lamdai = [0.2570,0.1528,0.2143,0.0818,0.1604,0.1337];
di = [230020,16000,58700,12600,42060,30200];
F(3:8) = lamdai.*(1 - sum(X')./di);
end


function [c,ceq] = Con_Fun(x)
%UNTITLED3 此处显示有关此函数的摘要
% 此处显示详细说明
X = reshape(x,6,11);
Y = zeros(6,11);
Y(X>0) = 1;
c(1:11) = 1 - sum(Y);
di = [230020,16000,58700,12600,42060,30200];
c(12:17) = (sum(X.*Y,2) - di')';
sj = [1320,1350,4500,1000,1000,2000,790,4200,200000,1000,190000];
c(18:28) = (sum(X.*Y) - sj)';
% 假设我们有以下需求量和上限
upper_limit =   ; % 上限

% 计算需求量总和
total_demand = sum(di);


% 根据需求量总和与上限的关系确定系数
if total_demand < upper_limit
% 如果需求量总和小于上限，系数为1.0（示例值，可以是任何大于0.8的数）
coefficient = 1.0;
else
% 如果需求量总和大于或等于上限，系数为0.8
coefficient = 0.8;
end

c(29:34) = (-sum(X.*Y,2) + coefficient*di')';
ceq = [];
end
